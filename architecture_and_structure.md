# Архитектура и структура монолитного приложения для LLM-чата

## 1. Общая архитектура

Приложение построено по **монолитной** архитектуре с разделением на клиентскую и серверную части в рамках одного репозитория (монорепо). Для обеспечения масштабируемости и надежности используется асинхронная обработка запросов через очередь сообщений (RabbitMQ).

**Ключевые компоненты:**

1.  **client (Nuxt 4)**: Клиентское приложение, отвечающее за пользовательский интерфейс, аутентификацию и отображение потоковых ответов (SSE).
2.  **server (NestJS)**: Серверное приложение, реализующее бизнес-логику, REST API, управление пользователями, диалогами и LLM-провайдерами.
3.  **Shared Types**: Общие TypeScript-типы для обеспечения строгой типизации между клиентом и сервером.
4.  **PostgreSQL**: Основное хранилище данных (пользователи, диалоги, сообщения, провайдеры).
5.  **RabbitMQ**: Брокер сообщений для реализации асинхронной очереди генерации LLM-ответов.
6.  **Nginx**: Обратный прокси-сервер, маршрутизирующий запросы к client и server, а также обеспечивающий корректную работу SSE.

## 2. Структура директорий

```
/llm-chat-monorepo
├── /server                 # Серверная часть (NestJS)
│   ├── /src
│   │   ├── /auth            # Модуль аутентификации (JWT, Google OAuth)
│   │   ├── /users           # Модуль управления пользователями
│   │   ├── /conversations   # Модуль управления диалогами
│   │   ├── /messages        # Модуль управления сообщениями
│   │   ├── /providers       # Модуль управления LLM-провайдерами
│   │   ├── /llm-gateway     # Сервис-адаптер для взаимодействия с внешними LLM API
│   │   ├── /queue           # Модуль для работы с RabbitMQ (отправка/получение задач)
│   │   ├── /database        # Конфигурация TypeORM, миграции, сущности
│   │   └── app.module.ts
│   ├── Dockerfile           # Dockerfile для server
│   └── package.json
├── /client                # Клиентская часть (Nuxt 4)
│   ├── /components
│   ├── /pages
│   ├── /composables
│   ├── /server              # Nuxt Server API (для OAuth callback)
│   ├── /assets
│   ├── Dockerfile           # Dockerfile для client
│   └── nuxt.config.ts
├── /shared                  # Общие TypeScript-типы
│   ├── /dtos                # Общие DTO (например, для сообщений)
│   └── /entities            # Общие типы сущностей
├── docker-compose.yml       # Конфигурация Docker Compose
├── nginx.conf               # Конфигурация Nginx
└── README.md                # Инструкции по запуску
```

## 3. Модули server (NestJS) и их ответственность

| Модуль            | Ответственность                                                                                                                        |
| :---------------- | :------------------------------------------------------------------------------------------------------------------------------------- |
| **Auth**          | Регистрация, вход (email/пароль), JWT-токены (access/refresh), Google OAuth, подтверждение почты.                                      |
| **Users**         | CRUD-операции для пользователей, управление профилем.                                                                                  |
| **Providers**     | Хранение конфигураций LLM-провайдеров (API-ключи, базовые URL, доступные модели).                                                      |
| **Conversations** | Создание, получение списка, удаление диалогов.                                                                                         |
| **Messages**      | Хранение истории сообщений.                                                                                                            |
| **Queue**         | Отправка задач на генерацию в RabbitMQ и обработка ответов.                                                                            |
| **LLM Gateway**   | Адаптер, инкапсулирующий логику вызова внешних LLM (OpenAI, Anthropic, Groq и др.). Получает задачу из очереди и возвращает результат. |

## 4. Поток запроса на генерацию (Request Flow)

1.  **client** отправляет `POST /api/messages` (новое сообщение) и сразу открывает **SSE-соединение** на `GET /api/conversations/:id/stream`.
2.  **server (MessagesController)**:
    - Сохраняет сообщение пользователя в БД.
    - Отправляет задачу на генерацию в **RabbitMQ (QueueModule)**.
    - Возвращает `202 Accepted` для `POST /api/messages`.
3.  **server (QueueConsumer)**:
    - Получает задачу из RabbitMQ.
    - Вызывает **LLM Gateway Service**.
4.  **LLM Gateway Service**:
    - Выбирает нужный адаптер (OpenAI, Anthropic и т.д.).
    - Вызывает внешний LLM API с историей диалога.
    - Получает ответ в виде потока (chunk-by-chunk).
    - Каждый полученный чанк отправляет обратно в **server (MessagesModule)** для стриминга.
5.  **server (MessagesModule)**:
    - Использует **SSE-контроллер** для отправки чанков данных через открытое соединение `GET /api/conversations/:id/stream` на **client**.
    - После завершения генерации сохраняет полное сообщение LLM в БД.
6.  **client**:
    - Получает чанки через SSE и отображает их в реальном времени.
    - После закрытия SSE-соединения разблокирует поле ввода.
